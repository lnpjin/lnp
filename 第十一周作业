第十一周
李能鹏
本周学习冒泡排序和希尔排序。
冒泡排序算法原理：
1.比较相邻的元素，如果第一个比第二个大，就交换他们；  
2.第一趟排序：第一个和第二个比较，若前者比后者大则交换；第二个和第三个比较满足前者较大则交换；随后依次进行相邻两个数的比较与交换，直到最后一对。第一趟排序结束后，最大的数将会出现在最后一位；  
3.第二趟排序：与2相同的步骤进行比较与交换。第二趟排序结束后，第二大的数将会出现在倒数第二位；  
此时第一趟排序之后产生的最大的数不应该参与本趟排序，即已经排好序的数不可参与后续的排序  
4.以此类推，之后每趟排序次数依次减少，直到没有任何一对数字需要比较
希尔排序算法原理：
希尔排序在不相邻的元素之间比较和交换。利用了插入排序的最佳时间代价特性，它试图将待排序序列变成基本有序的，然后再用插入排序来完成排序工作。
在执行每一次循环时，希尔排序把序列分为互不相连的子序列，并使各个子序列中的元素在整个数组中的间距相同，每个子序列用插入排序进行排序。

冒泡排序和希尔排序

class Bubble_Sort
{
public:
	void Sort(int arr[], int time)
	{
		int temp;//临时变量
		bool flag;//是否继续交换的标志
		for (int i = 0; i < time - 1; i++)      //表示趟数，一共需要n-1趟
		{
			for (int j = 0; j < time - i - 1; j++)
			{
				flag = false;                   //每次遍历先设置flag为false，才能判断后面元素是否发生交换
				if (arr[j] > arr[j + 1])
				{
					temp = arr[j];
					arr[j] = arr[j + 1];
					arr[j + 1] = temp;         //实现交换，把最大的数放到最后一位
					flag = true;               //只要发生交换flag就设置为true
				}
			}
			if (!flag) break;                  //如果flag在本趟循环中始终为false，说明后面元素已经有序，跳出循环即可
		}
	}
};


class Shell_Sort
{
public:
    void Sort(int a[], int n)                      //a:待排序的数组, n:数组的长度
    {
        int i, j, gap;                             // gap为步长，每次减为原来的一半
        for (gap = n / 2; gap > 0; gap /= 2)
        {
            // 共gap个组，对每一组都执行直接插入排序
            for (i = 0; i < gap; i++)
            {
                for (j = i + gap; j < n; j += gap)
                {
                    // 如果a[j] < a[j-gap]，则寻找a[j]位置，并将后面数据的位置都后移
                    if (a[j] < a[j - gap])
                    {
                        int tmp = a[j];
                        int k = j - gap;
                        while (k >= 0 && a[k] > tmp)
                        {
                            a[k + gap] = a[k];
                            k -= gap;
                        }
                        a[k + gap] = tmp;
                    }
                }
            }
        }

};
